/*
演習12-1 前置演算子と後置演算子は行うことが同じである。
前置演算子関数から後置演算子関数を呼び出すか、後置演算子関数から前置演算子関数を呼び出すか
どちらの実現が好ましいか検討すること

作成日 2017年5月10日

編集日 2017年5月12日

作成者 平澤敬介
*/

#ifndef CLASS_H_
#define CLASS_H_

// 前置演算子と後置演算子の使い方 メリット デメリットを検討するために
// 単純なカウンタを作り確認します
class Count{
	int cnt;// データメンバを定義する 前置演算子と後置演算子で値の移り変わりを見るだけなので
	// 1つで十分
public:
	Count()// コンストラクタ データメンバ を0で初期化する
		:  cnt(0)// 前置演算子と後置演算子で加算を行う
	{
	}

	// カウントした値を返却するメンバ関数
	// 関数名がないのでなく opereator int で型を持った関数になる
	operator int(){ return cnt; }

	//前置演算子 でインクリメントを行う	返却する型は、＆が付くことにより
	//クラスへの参照になる また、thisポインタで自分自身への参照を返却する
	Count& operator++() {
			cnt++;
			return *this;
	}

	//後置演算子 でインクリメントを行う *thisで自分自身の値を変数に保存しておく
	// インクリメント前の値を返却してから インクリメントする。表示はされていないが、データメンバはインクリメントされている
	//後置演算子を呼び出したとき、データメンバはインクリメントされるが
	// 表示される値は 1つ前の値になる
	Count operator++(int) {
			Count x = *this;
			cnt++;
			return x;
	}

};



#endif /* CLASS_H_ */
