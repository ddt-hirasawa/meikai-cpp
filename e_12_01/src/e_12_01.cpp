/*
演習12-1 前置演算子と後置演算子は行うことが同じである。
前置演算子関数から後置演算子関数を呼び出すか、後置演算子関数から前置演算子関数を呼び出すか
どちらの実現が好ましいか検討すること

作成日 2017年5月10日

作成者 平澤敬介
*/

#include<iostream>
#include"class.h"

using namespace std;


int main()
{
	count tmp;	// 前置演算子と後置演算子を使うための変数を定義する

	//前置演算子を使ったインクリメント1がデータメンバに加算される
	++tmp;

	//後置演算子を使ったインクリメント1がデータメンバに加算される
	tmp++;

	// 2回インクリメントされるため当然 2 と表示される
	cout << "前置演算子と後置演算子でインクリメントされている : " << tmp;
	cout << "\n";

	//thisポインタによる参照が返却される前にインクリメントされるため
	// 表示される値もインクリメントされた値が表示される
	cout << "前置演算子の場合 (インクリメントされるはず) : " << ++tmp;
	cout << "\n";

	//返却の前にインクリメントされているが、返却される値は保存されている
	// 1つ前の値なのでインクリメントされた値は表示されない
	//実際のデータメンバは加算されている
	cout << "後置演算子の場合 (インクリメントされるはず) : "<< tmp++;

	cout << "\n";
	// 後置演算子が機能していることがわかる
	// ここではデータメンバを呼び出しているので後置演算子が機能していなければ
	// 3のままのはずだから
	cout << "最終敵にインクリメントされている値 : " << tmp;

	return 0;
}

// 前置演算子のほうが、参照渡しを行っているため実引数が書き換えられる可能性があっても
/* 便利だと思います。また、インクリメントした後にthisポインタで参照を返却するという手順が
 * シンプルで覚えやすいです。後置演算子では、インクリメントされた値が表示できないこともあり
 * 手順も 一時的に変数に値を補完するなど、前置演算子と比べ複雑になっているため覚えづらいです
 * ただし、参照が使えない場面があれば後置演算子を使わざるを得ないので覚えておく必要はあると思います。
 */
